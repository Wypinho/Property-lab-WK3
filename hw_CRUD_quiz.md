# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?
- console.rb lines 6, 15 & 24, property.rb lines 71, 84 & 97

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?
- properties.sql under CREATE TABLE

Q3. In `console.rb`, which lines modify the database?
- lines 4, 13, 22, 31, 33

Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?
- Because ID doesn't exist at that point. It's created at the point the data is saved to the database (property.rb, line 32)

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?
- property.rb, line 32. db.exec_prepared("save", values) returns an array containing a hash. We capture the data in array position 0, and hash key 'id', and assign it to the variable @id

Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?
Because when we call the constructor from console.rb the id has not been assigned yet, with later calls it has. This ensures the same code works in both cases.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?

Q9. Why do we use prepared statements when performing database operations?

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?

Q11. What are their return values?
